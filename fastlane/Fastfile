# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out:
#   https://docs.fastlane.tools/actions
# For a list of all available plugins, check out:
#   https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

platform :ios do

  # ---------------------------------------------------------------------------
  # Main entry lane for CI. This lane will try to build and upload the app
  # using manual signing first, and fall back to cloud signing if it fails.
  # ---------------------------------------------------------------------------
  desc "Build and upload the app to TestFlight"
  lane :build_and_upload do
    setup_ci_environment
    build_and_upload_manually
  end

  # ---------------------------------------------------------------------------
  # Private Lanes - Implementation Details
  # ---------------------------------------------------------------------------

  # --- Build Method 1: Manual Signing ---
  # This lane uses a certificate and provisioning profile stored in secrets.
  private_lane :build_and_upload_manually do
    begin
      UI.header("Attempting build with manual signing...")

      # Ensure secrets are available
      unless ENV['DISTRIBUTION_CERTIFICATE'] && ENV['APP_STORE_PROVISIONING_PROFILE_BASE64']
        UI.important("Manual signing secrets not found. Skipping to cloud signing.")
        build_with_api_key
        return
      end

      # Install the provisioning profile from a base64 encoded secret
      profile_path = install_provisioning_profile_from_secret(
        secret_name: 'APP_STORE_PROVISIONING_PROFILE_BASE64',
        profile_name: 'AppStore_Profile.mobileprovision'
      )
      
      # Get the UUID of the installed profile to avoid name ambiguity
      profile_uuid = Fastlane::Actions::GetProvisioningProfileInfoAction.run(path: profile_path)[:uuid]
      UI.message("Provisioning Profile UUID: #{profile_uuid}")

      # Update project settings to use manual signing with the specific profile UUID
      update_code_signing_settings(
        use_automatic_signing: false,
        targets: ["CD starter project"],
        code_sign_identity: "Apple Distribution", # Use "Apple Distribution" for modern Xcode
        profile_uuid: profile_uuid,
        team_id: ENV['TEAM_ID'],
        path: "CD starter project.xcodeproj"
      )
      
      UI.message("üèóÔ∏è Building and archiving with manual signing settings...")

      # Build the app using the manual settings
      gym(
        project: "CD starter project.xcodeproj",
        scheme: "CD starter project",
        configuration: "Release",
        output_directory: "./build",
        output_name: "CD_starter_project",
        clean: true,
        export_method: "app-store",
        export_options: {
          method: "app-store",
          signingStyle: "manual",
          teamID: ENV['TEAM_ID'],
          provisioningProfiles: {
            "com.othmanshahrouri.cd.starter.project" => profile_uuid
          }
        }
      )

      UI.success("‚úÖ Build successful with manual signing!")
      
      # If build is successful, proceed to upload
      upload_tf

    rescue => e
      UI.error("‚ùå Manual signing failed: #{e.message}")
      UI.important("üí° Falling back to cloud signing with App Store Connect API Key...")
      build_with_api_key
    end
  end

  # --- Build Method 2: Cloud Signing (Fallback) ---
  # This lane uses the App Store Connect API key to let Xcode manage signing.
  private_lane :build_with_api_key do
    UI.header("Attempting build with cloud signing (App Store Connect API Key)...")
    setup_api_key

    # Ensure project is set for automatic signing
    update_code_signing_settings(
      use_automatic_signing: true,
      team_id: ENV['TEAM_ID'],
      path: "CD starter project.xcodeproj"
    )

    # Build the app, passing the API key to xcodebuild for cloud signing
    gym(
      project: "CD starter project.xcodeproj",
      scheme: "CD starter project",
      configuration: "Release",
      output_directory: "./build",
      output_name: "CD_starter_project",
      clean: true,
      export_method: "app-store",
      xcargs: "-allowProvisioningUpdates " +
              "-authenticationKeyPath '#{lane_context[SharedValues::APP_STORE_CONNECT_API_KEY_PATH]}' " +
              "-authenticationKeyID '#{ENV['API_KEY_ID']}' " +
              "-authenticationKeyIssuerID '#{ENV['API_ISSUER_ID']}'"
    )

    UI.success("‚úÖ Build successful with cloud signing!")

    # If build is successful, proceed to upload
    upload_tf
  end
  
  # --- Upload Lane ---
  private_lane :upload_tf do
    UI.header("üöÄ Uploading to TestFlight...")
    setup_api_key # Ensure API key is set for upload
    
    upload_to_testflight(
      ipa: "./build/CD_starter_project.ipa",
      skip_waiting_for_build_processing: true,
      notify_external_testers: false
    )
    UI.success("üéâ Successfully uploaded to TestFlight!")
  end


  # ---------------------------------------------------------------------------
  # Helper Lanes
  # ---------------------------------------------------------------------------

  # Sets up the App Store Connect API key for use in other lanes
  private_lane :setup_api_key do
    app_store_connect_api_key(
      key_id: ENV["API_KEY_ID"],
      issuer_id: ENV["API_ISSUER_ID"],
      key_content: ENV["API_KEY_BASE64"],
      is_key_content_base64: true
    )
    UI.success("‚úÖ API key setup successful")
  end

  # Creates a temporary keychain and imports necessary certificates for CI
  private_lane :setup_ci_environment do
    UI.header("üîß Setting up CI environment...")
    
    # Create a temporary keychain
    keychain_name = "fastlane_tmp_keychain"
    keychain_password = "temp_password"
    create_keychain(
      name: keychain_name,
      password: keychain_password,
      default_keychain: true,
      unlock: true,
      timeout: 3600
    )
    
    # Import Apple WWDR certificates
    sh("curl -o /tmp/AppleWWDRCAG3.cer https://developer.apple.com/certificationauthority/AppleWWDRCAG3.cer")
    import_certificate(certificate_path: "/tmp/AppleWWDRCAG3.cer", keychain_name: keychain_name)
    
    # Import the distribution certificate from secrets, if it exists
    if ENV["DISTRIBUTION_CERTIFICATE"] && !ENV["DISTRIBUTION_CERTIFICATE"].empty?
      UI.message("üì± Importing Distribution certificate...")
      cert_path = "/tmp/distribution.p12"
      File.binwrite(cert_path, Base64.decode64(ENV['DISTRIBUTION_CERTIFICATE']))
      
      import_certificate(
        certificate_path: cert_path,
        certificate_password: ENV["DISTRIBUTION_PASSWORD"] || "",
        keychain_name: keychain_name
      )
      UI.success("‚úÖ Distribution certificate imported")
    else
      UI.message("‚ö†Ô∏è No Distribution certificate provided. Manual signing will be skipped.")
    end
  end

  # Installs a provisioning profile from a base64 encoded environment variable
  private_lane :install_provisioning_profile_from_secret do |options|
    secret = ENV[options[:secret_name]]
    profile_path = "/tmp/#{options[:profile_name]}"
    
    File.binwrite(profile_path, Base64.decode64(secret))
    
    install_provisioning_profile(path: profile_path)
    
    UI.success("‚úÖ Provisioning profile installed from secret")
    
    # Return the path for later use
    profile_path
  end

  # ---------------------------------------------------------------------------
  # Testing lane expected by CI workflow
  # ---------------------------------------------------------------------------
  desc "Run unit tests"
  lane :test do
    run_tests(
      project: "CD starter project.xcodeproj",
      scheme: "CD starter project",
      clean: true,
      device: "iPhone 15"
    )
  end

end
